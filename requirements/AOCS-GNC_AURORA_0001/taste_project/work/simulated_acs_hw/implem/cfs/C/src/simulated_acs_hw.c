//  ------------------------------------------------------------------------
//
//                           Q G e n   T u t o r i a l
//
//                       Simulated ACS Hardware component
//
//           Copyright (C) 2022 Universidad Polit√©cnica de Madrid
//
//  This is free software;  you can redistribute it  and/or modify it  under
//  terms of the  GNU General Public License as published  by the Free Soft-
//  ware  Foundation;  either version 3,  or (at your option) any later ver-
//  sion.  This software is distributed in the hope  that it will be useful,
//  but WITHOUT ANY WARRANTY;  without even the implied warranty of MERCHAN-
//  TABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
//  License for  more details.  You should have  received  a copy of the GNU
//  General  Public  License  distributed  with  this  software;   see  file
//  COPYING3.  If not, go to http://www.gnu.org/licenses for a complete copy
//  of the license.
//
//  ------------------------------------------------------------------------

/* Body file for function Simulated_ACS_HW
 * Generated by TASTE on 2022-06-06 16:04:12
 * You can edit this file, it will not be overwritten
 * Provided interfaces : Read_MGM, control_MGT
 * Required interfaces : 
 * User-defined properties for this function:
 * Timers              : 
 */

#include "simulated_acs_hw.h"

#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>	//write
#include <arpa/inet.h>
#include <errno.h>
#include <string.h>

// =========================
// Private types & constants
// =========================

#define ADDRESS ("127.0.0.1")
#define PORT    (5000)

static int fd_recv;
static int fd_send;

// =================
// Private functions
// =================

static int create_server_socket() {
    int fd_server;
    struct sockaddr_in server;
    int enable = 1;

    // 1. Create socket for the servers:
    fd_server = socket(AF_INET, SOCK_STREAM, 0);
    if (fd_server < 0) {
        puts("[Simulated_ACS_HW] creation of the socket for the server failed");
        return -1;
    } else {
        server.sin_family = AF_INET;
        server.sin_port = htons(PORT);
        server.sin_addr.s_addr = inet_addr(ADDRESS);
        if (setsockopt(fd_server, SOL_SOCKET, SO_REUSEADDR, &enable, sizeof(int)) < 0) {
            perror("[Simulated_ACS_HW] setsockopt(SO_REUSEADDR) failed");
        }
        if (setsockopt(fd_server, SOL_SOCKET, SO_REUSEPORT, &enable, sizeof(int)) < 0) {
            perror("[Simulated_ACS_HW] setsockopt(SO_REUSEPORT) failed");
        }

        struct timeval timeout;
        timeout.tv_sec  = 20;
        timeout.tv_usec = 0;
        if (setsockopt(fd_server, SOL_SOCKET, SO_RCVTIMEO, (char *)&timeout, sizeof(timeout)) < 0) {
            perror("[Simulated_ACS_HW] setsockopt failed\n");
        }
        if (setsockopt(fd_server, SOL_SOCKET, SO_SNDTIMEO, (char *)&timeout, sizeof(timeout)) < 0) {
            perror("[Simulated_ACS_HW] setsockopt failed\n");
        }
    }

    // 2. Bind server information to the server socket
    int res = bind(fd_server, (struct sockaddr*) &server, sizeof(struct sockaddr));
    if(res < 0) {
        perror("[Simulated_ACS_HW] could not bind server information");
        return -1;
    }

    return fd_server;
}

static int accept_the_client(int fd_server) {
    unsigned int sin_size = sizeof(struct sockaddr_in);
    struct sockaddr_in client;
    int fd_client = accept(fd_server, (struct sockaddr *) &client, &sin_size);
    if (fd_client < 0) {
        perror("[Simulated_ACS_HW] Could not accecpt the client");
        return -1;
    } else {
        puts("[Simulated_ACS_HW] Client accepted!");
    }

    struct timeval timeout;
    timeout.tv_sec  = 20;
    timeout.tv_usec = 0;
    if (setsockopt(fd_client, SOL_SOCKET, SO_RCVTIMEO, (char *)&timeout, sizeof(timeout)) < 0) {
        perror("setsockopt failed\n");
    }
    if (setsockopt(fd_client, SOL_SOCKET, SO_SNDTIMEO, (char *)&timeout, sizeof(timeout)) < 0) {
        perror("setsockopt failed\n");
    }

    return fd_client;
}

// ==================================
// Provided interfaces implementation
// ==================================

void simulated_acs_hw_startup(void)
{
    // 1. Create socker for the server:
    int fd_server = create_server_socket();

    // 2. Listen for a client:
    listen(fd_server, 3);

    // 3. Accept the client connection:
    int fd_client = accept_the_client(fd_server);

    fd_recv = fd_client;
    fd_send = fd_client;

    puts("[Simulated_ACS_HW] Started");
}

void simulated_acs_hw_PI_Read_MGM
      (asn1SccT_B_b_T *OUT_bbt)

{
    if (fd_recv < 0) {
        return;
    }

    for (int i = 0; i < 15; i++) {
        float received_value = 0.0;
        int nbytes = recv(fd_recv, (void *) &received_value, sizeof(received_value), 0);

        printf("Received %d bytes from client\n", nbytes);
        if (nbytes < 0) {
            puts("Error in socket.");
            fprintf(stderr, "recv: %s (%d)\n", strerror(errno), errno);
        } else {
            OUT_bbt->arr[i] = received_value;
            printf("|\t%f\t|", OUT_bbt->arr[i]);
        }
    }
}


void simulated_acs_hw_PI_control_MGT
      (const asn1SccT_Control *IN_control)

{
    if (fd_send < 0) {
        return;
    }

    float to_be_sent[3];

    printf("CTRL: {%f, %f, %f}\n", IN_control->arr[0], IN_control->arr[1], IN_control->arr[2]);
    for (int i = 0; i < 3; ++i) {
        to_be_sent[i] = IN_control->arr[i];
    }

    if (send (fd_send, (void *) &to_be_sent, sizeof(to_be_sent), 0) < 0) {
        perror("send");
    } else {
        puts("Send data went fine!\n");
    }
}
