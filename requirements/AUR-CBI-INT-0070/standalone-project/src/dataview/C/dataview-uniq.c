/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>

#include "asn1crt_encoding.h"
#include "asn1crt_encoding_uper.h"
#include "asn1crt_encoding_acn.h"

#include "dataview-uniq.h"




flag asn1SccAuroraInt_Equal(const asn1SccAuroraInt* pVal1, const asn1SccAuroraInt* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccAuroraInt_IsConstraintValid(const asn1SccAuroraInt* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-1000000L <= (*(pVal))) && ((*(pVal)) <= 1000000L));
    *pErrCode = ret ? 0 :  ERR_AURORAINT; 

	return ret;
}

void asn1SccAuroraInt_Initialize(asn1SccAuroraInt* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccAuroraInt_Encode(const asn1SccAuroraInt* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccAuroraInt_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -1000000, 1000000);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccAuroraInt_Decode(asn1SccAuroraInt* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -1000000, 1000000);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_AURORAINT;

	return ret  && asn1SccAuroraInt_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccAuroraInt_ACN_Encode(const asn1SccAuroraInt* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccAuroraInt_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -1000000, 1000000);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccAuroraInt_ACN_Decode(asn1SccAuroraInt* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -1000000, 1000000);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_AURORAINT;

    return ret && asn1SccAuroraInt_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccAuroraUInt_Equal(const asn1SccAuroraUInt* pVal1, const asn1SccAuroraUInt* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccAuroraUInt_IsConstraintValid(const asn1SccAuroraUInt* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 1000000UL);
    *pErrCode = ret ? 0 :  ERR_AURORAUINT; 

	return ret;
}

void asn1SccAuroraUInt_Initialize(asn1SccAuroraUInt* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccAuroraUInt_Encode(const asn1SccAuroraUInt* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccAuroraUInt_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 1000000);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccAuroraUInt_Decode(asn1SccAuroraUInt* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 1000000);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_AURORAUINT;

	return ret  && asn1SccAuroraUInt_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccAuroraUInt_ACN_Encode(const asn1SccAuroraUInt* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccAuroraUInt_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 1000000);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccAuroraUInt_ACN_Decode(asn1SccAuroraUInt* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 1000000);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_AURORAUINT;

    return ret && asn1SccAuroraUInt_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccAuroraReal_Equal(const asn1SccAuroraReal* pVal1, const asn1SccAuroraReal* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccAuroraReal_IsConstraintValid(const asn1SccAuroraReal* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-1.0000000000000000000E+006 <= (*(pVal))) && ((*(pVal)) <= 1.0000000000000000000E+006));
    *pErrCode = ret ? 0 :  ERR_AURORAREAL; 

	return ret;
}

void asn1SccAuroraReal_Initialize(asn1SccAuroraReal* pVal)
{
	(void)pVal;


	(*(pVal)) = 0.0000000000000000000E+000;
}

flag asn1SccAuroraReal_Encode(const asn1SccAuroraReal* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccAuroraReal_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeReal(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccAuroraReal_Decode(asn1SccAuroraReal* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeReal(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_AURORAREAL;

	return ret  && asn1SccAuroraReal_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccAuroraReal_ACN_Encode(const asn1SccAuroraReal* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccAuroraReal_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeReal(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccAuroraReal_ACN_Decode(asn1SccAuroraReal* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeReal(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_AURORAREAL;

    return ret && asn1SccAuroraReal_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccAuroraVoltage_Equal(const asn1SccAuroraVoltage* pVal1, const asn1SccAuroraVoltage* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccAuroraVoltage_IsConstraintValid(const asn1SccAuroraVoltage* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccAuroraReal_IsConstraintValid(pVal, pErrCode);
    if (ret) {
        ret = ((0.0000000000000000000E+000 <= (*(pVal))) && ((*(pVal)) <= 1.0000000000000000000E+005));
        *pErrCode = ret ? 0 :  ERR_AURORAVOLTAGE_2; 
    }   /*COVERAGE_IGNORE*/

	return ret;
}

void asn1SccAuroraVoltage_Initialize(asn1SccAuroraVoltage* pVal)
{
	(void)pVal;


	(*(pVal)) = 0.0000000000000000000E+000;
}

flag asn1SccAuroraVoltage_Encode(const asn1SccAuroraVoltage* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccAuroraVoltage_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    ret = asn1SccAuroraReal_Encode(pVal, pBitStrm, pErrCode, FALSE);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccAuroraVoltage_Decode(asn1SccAuroraVoltage* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = asn1SccAuroraReal_Decode(pVal, pBitStrm, pErrCode);

	return ret  && asn1SccAuroraVoltage_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccAuroraVoltage_ACN_Encode(const asn1SccAuroraVoltage* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccAuroraVoltage_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeReal(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccAuroraVoltage_ACN_Decode(asn1SccAuroraVoltage* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeReal(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_AURORAVOLTAGE;

    return ret && asn1SccAuroraVoltage_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccAuroraCurrent_Equal(const asn1SccAuroraCurrent* pVal1, const asn1SccAuroraCurrent* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccAuroraCurrent_IsConstraintValid(const asn1SccAuroraCurrent* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccAuroraReal_IsConstraintValid(pVal, pErrCode);
    if (ret) {
        ret = ((0.0000000000000000000E+000 <= (*(pVal))) && ((*(pVal)) <= 1.0000000000000000000E+004));
        *pErrCode = ret ? 0 :  ERR_AURORACURRENT_2; 
    }   /*COVERAGE_IGNORE*/

	return ret;
}

void asn1SccAuroraCurrent_Initialize(asn1SccAuroraCurrent* pVal)
{
	(void)pVal;


	(*(pVal)) = 0.0000000000000000000E+000;
}

flag asn1SccAuroraCurrent_Encode(const asn1SccAuroraCurrent* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccAuroraCurrent_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    ret = asn1SccAuroraReal_Encode(pVal, pBitStrm, pErrCode, FALSE);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccAuroraCurrent_Decode(asn1SccAuroraCurrent* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = asn1SccAuroraReal_Decode(pVal, pBitStrm, pErrCode);

	return ret  && asn1SccAuroraCurrent_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccAuroraCurrent_ACN_Encode(const asn1SccAuroraCurrent* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccAuroraCurrent_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeReal(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccAuroraCurrent_ACN_Decode(asn1SccAuroraCurrent* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeReal(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_AURORACURRENT;

    return ret && asn1SccAuroraCurrent_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccAuroraPWM_Equal(const asn1SccAuroraPWM* pVal1, const asn1SccAuroraPWM* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccAuroraPWM_IsConstraintValid(const asn1SccAuroraPWM* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccAuroraReal_IsConstraintValid(pVal, pErrCode);
    if (ret) {
        ret = ((0.0000000000000000000E+000 <= (*(pVal))) && ((*(pVal)) <= 1.0000000000000000000E+000));
        *pErrCode = ret ? 0 :  ERR_AURORAPWM_2; 
    }   /*COVERAGE_IGNORE*/

	return ret;
}

void asn1SccAuroraPWM_Initialize(asn1SccAuroraPWM* pVal)
{
	(void)pVal;


	(*(pVal)) = 0.0000000000000000000E+000;
}

flag asn1SccAuroraPWM_Encode(const asn1SccAuroraPWM* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccAuroraPWM_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    ret = asn1SccAuroraReal_Encode(pVal, pBitStrm, pErrCode, FALSE);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccAuroraPWM_Decode(asn1SccAuroraPWM* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = asn1SccAuroraReal_Decode(pVal, pBitStrm, pErrCode);

	return ret  && asn1SccAuroraPWM_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccAuroraPWM_ACN_Encode(const asn1SccAuroraPWM* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccAuroraPWM_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeReal(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccAuroraPWM_ACN_Decode(asn1SccAuroraPWM* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeReal(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_AURORAPWM;

    return ret && asn1SccAuroraPWM_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccAuroraPIDValue_Equal(const asn1SccAuroraPIDValue* pVal1, const asn1SccAuroraPIDValue* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccAuroraPIDValue_IsConstraintValid(const asn1SccAuroraPIDValue* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccAuroraReal_IsConstraintValid(pVal, pErrCode);
    if (ret) {
        ret = ((-1.0000000000000000000E+002 <= (*(pVal))) && ((*(pVal)) <= 1.0000000000000000000E+002));
        *pErrCode = ret ? 0 :  ERR_AURORAPIDVALUE_2; 
    }   /*COVERAGE_IGNORE*/

	return ret;
}

void asn1SccAuroraPIDValue_Initialize(asn1SccAuroraPIDValue* pVal)
{
	(void)pVal;


	(*(pVal)) = 0.0000000000000000000E+000;
}

flag asn1SccAuroraPIDValue_Encode(const asn1SccAuroraPIDValue* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccAuroraPIDValue_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    ret = asn1SccAuroraReal_Encode(pVal, pBitStrm, pErrCode, FALSE);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccAuroraPIDValue_Decode(asn1SccAuroraPIDValue* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = asn1SccAuroraReal_Decode(pVal, pBitStrm, pErrCode);

	return ret  && asn1SccAuroraPIDValue_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccAuroraPIDValue_ACN_Encode(const asn1SccAuroraPIDValue* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccAuroraPIDValue_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeReal(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccAuroraPIDValue_ACN_Decode(asn1SccAuroraPIDValue* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeReal(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_AURORAPIDVALUE;

    return ret && asn1SccAuroraPIDValue_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccAuroraTemperature_Equal(const asn1SccAuroraTemperature* pVal1, const asn1SccAuroraTemperature* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccAuroraTemperature_IsConstraintValid(const asn1SccAuroraTemperature* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccAuroraReal_IsConstraintValid(pVal, pErrCode);
    if (ret) {
        ret = ((0.0000000000000000000E+000 <= (*(pVal))) && ((*(pVal)) <= 1.0000000000000000000E+003));
        *pErrCode = ret ? 0 :  ERR_AURORATEMPERATURE_2; 
    }   /*COVERAGE_IGNORE*/

	return ret;
}

void asn1SccAuroraTemperature_Initialize(asn1SccAuroraTemperature* pVal)
{
	(void)pVal;


	(*(pVal)) = 0.0000000000000000000E+000;
}

flag asn1SccAuroraTemperature_Encode(const asn1SccAuroraTemperature* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccAuroraTemperature_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    ret = asn1SccAuroraReal_Encode(pVal, pBitStrm, pErrCode, FALSE);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccAuroraTemperature_Decode(asn1SccAuroraTemperature* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = asn1SccAuroraReal_Decode(pVal, pBitStrm, pErrCode);

	return ret  && asn1SccAuroraTemperature_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccAuroraTemperature_ACN_Encode(const asn1SccAuroraTemperature* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccAuroraTemperature_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeReal(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccAuroraTemperature_ACN_Decode(asn1SccAuroraTemperature* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeReal(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_AURORATEMPERATURE;

    return ret && asn1SccAuroraTemperature_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccAuroraFlowRate_Equal(const asn1SccAuroraFlowRate* pVal1, const asn1SccAuroraFlowRate* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccAuroraFlowRate_IsConstraintValid(const asn1SccAuroraFlowRate* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccAuroraReal_IsConstraintValid(pVal, pErrCode);
    if (ret) {
        ret = ((0.0000000000000000000E+000 <= (*(pVal))) && ((*(pVal)) <= 1.0000000000000000000E+002));
        *pErrCode = ret ? 0 :  ERR_AURORAFLOWRATE_2; 
    }   /*COVERAGE_IGNORE*/

	return ret;
}

void asn1SccAuroraFlowRate_Initialize(asn1SccAuroraFlowRate* pVal)
{
	(void)pVal;


	(*(pVal)) = 0.0000000000000000000E+000;
}

flag asn1SccAuroraFlowRate_Encode(const asn1SccAuroraFlowRate* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccAuroraFlowRate_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    ret = asn1SccAuroraReal_Encode(pVal, pBitStrm, pErrCode, FALSE);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccAuroraFlowRate_Decode(asn1SccAuroraFlowRate* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = asn1SccAuroraReal_Decode(pVal, pBitStrm, pErrCode);

	return ret  && asn1SccAuroraFlowRate_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccAuroraFlowRate_ACN_Encode(const asn1SccAuroraFlowRate* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccAuroraFlowRate_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeReal(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccAuroraFlowRate_ACN_Decode(asn1SccAuroraFlowRate* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeReal(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_AURORAFLOWRATE;

    return ret && asn1SccAuroraFlowRate_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccAuroraBatteryCapacity_Equal(const asn1SccAuroraBatteryCapacity* pVal1, const asn1SccAuroraBatteryCapacity* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccAuroraBatteryCapacity_IsConstraintValid(const asn1SccAuroraBatteryCapacity* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccAuroraReal_IsConstraintValid(pVal, pErrCode);
    if (ret) {
        ret = ((0.0000000000000000000E+000 <= (*(pVal))) && ((*(pVal)) <= 1.0000000000000000000E+000));
        *pErrCode = ret ? 0 :  ERR_AURORABATTERYCAPACITY_2; 
    }   /*COVERAGE_IGNORE*/

	return ret;
}

void asn1SccAuroraBatteryCapacity_Initialize(asn1SccAuroraBatteryCapacity* pVal)
{
	(void)pVal;


	(*(pVal)) = 0.0000000000000000000E+000;
}

flag asn1SccAuroraBatteryCapacity_Encode(const asn1SccAuroraBatteryCapacity* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccAuroraBatteryCapacity_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    ret = asn1SccAuroraReal_Encode(pVal, pBitStrm, pErrCode, FALSE);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccAuroraBatteryCapacity_Decode(asn1SccAuroraBatteryCapacity* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = asn1SccAuroraReal_Decode(pVal, pBitStrm, pErrCode);

	return ret  && asn1SccAuroraBatteryCapacity_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccAuroraBatteryCapacity_ACN_Encode(const asn1SccAuroraBatteryCapacity* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccAuroraBatteryCapacity_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeReal(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccAuroraBatteryCapacity_ACN_Decode(asn1SccAuroraBatteryCapacity* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeReal(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_AURORABATTERYCAPACITY;

    return ret && asn1SccAuroraBatteryCapacity_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccAuroraControllerStatus_Equal(const asn1SccAuroraControllerStatus* pVal1, const asn1SccAuroraControllerStatus* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->payload_temperature == pVal2->payload_temperature);

    if (ret) {
        ret = (pVal1->payload_flow_rate == pVal2->payload_flow_rate);

        if (ret) {
            ret = (pVal1->battery_capacity == pVal2->battery_capacity);

            if (ret) {
                ret = (pVal1->solar_panel_voltage == pVal2->solar_panel_voltage);

                if (ret) {
                    ret = (pVal1->solar_panel_current == pVal2->solar_panel_current);

                }

            }

        }

    }

	return ret;

}

flag asn1SccAuroraControllerStatus_IsConstraintValid(const asn1SccAuroraControllerStatus* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccAuroraTemperature_IsConstraintValid((&(pVal->payload_temperature)), pErrCode);
    if (ret) {
        ret = asn1SccAuroraFlowRate_IsConstraintValid((&(pVal->payload_flow_rate)), pErrCode);
        if (ret) {
            ret = asn1SccAuroraBatteryCapacity_IsConstraintValid((&(pVal->battery_capacity)), pErrCode);
            if (ret) {
                ret = asn1SccAuroraVoltage_IsConstraintValid((&(pVal->solar_panel_voltage)), pErrCode);
                if (ret) {
                    ret = asn1SccAuroraCurrent_IsConstraintValid((&(pVal->solar_panel_current)), pErrCode);
                }   /*COVERAGE_IGNORE*/
            }   /*COVERAGE_IGNORE*/
        }   /*COVERAGE_IGNORE*/
    }   /*COVERAGE_IGNORE*/

	return ret;
}

void asn1SccAuroraControllerStatus_Initialize(asn1SccAuroraControllerStatus* pVal)
{
	(void)pVal;



	/*set payload_temperature */
	asn1SccAuroraTemperature_Initialize((&(pVal->payload_temperature)));
	/*set payload_flow_rate */
	asn1SccAuroraFlowRate_Initialize((&(pVal->payload_flow_rate)));
	/*set battery_capacity */
	asn1SccAuroraBatteryCapacity_Initialize((&(pVal->battery_capacity)));
	/*set solar_panel_voltage */
	asn1SccAuroraVoltage_Initialize((&(pVal->solar_panel_voltage)));
	/*set solar_panel_current */
	asn1SccAuroraCurrent_Initialize((&(pVal->solar_panel_current)));
}

flag asn1SccAuroraControllerStatus_Encode(const asn1SccAuroraControllerStatus* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccAuroraControllerStatus_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode payload_temperature */
	    ret = asn1SccAuroraTemperature_Encode((&(pVal->payload_temperature)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode payload_flow_rate */
	        ret = asn1SccAuroraFlowRate_Encode((&(pVal->payload_flow_rate)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode battery_capacity */
	            ret = asn1SccAuroraBatteryCapacity_Encode((&(pVal->battery_capacity)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode solar_panel_voltage */
	                ret = asn1SccAuroraVoltage_Encode((&(pVal->solar_panel_voltage)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode solar_panel_current */
	                    ret = asn1SccAuroraCurrent_Encode((&(pVal->solar_panel_current)), pBitStrm, pErrCode, FALSE);
	                }   /*COVERAGE_IGNORE*/
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccAuroraControllerStatus_Decode(asn1SccAuroraControllerStatus* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode payload_temperature */
	ret = asn1SccAuroraTemperature_Decode((&(pVal->payload_temperature)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode payload_flow_rate */
	    ret = asn1SccAuroraFlowRate_Decode((&(pVal->payload_flow_rate)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode battery_capacity */
	        ret = asn1SccAuroraBatteryCapacity_Decode((&(pVal->battery_capacity)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode solar_panel_voltage */
	            ret = asn1SccAuroraVoltage_Decode((&(pVal->solar_panel_voltage)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode solar_panel_current */
	                ret = asn1SccAuroraCurrent_Decode((&(pVal->solar_panel_current)), pBitStrm, pErrCode);
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
	}   /*COVERAGE_IGNORE*/

	return ret  && asn1SccAuroraControllerStatus_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccAuroraControllerStatus_ACN_Encode(const asn1SccAuroraControllerStatus* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccAuroraControllerStatus_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode payload_temperature */
	    ret = asn1SccAuroraTemperature_ACN_Encode((&(pVal->payload_temperature)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode payload_flow_rate */
	        ret = asn1SccAuroraFlowRate_ACN_Encode((&(pVal->payload_flow_rate)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode battery_capacity */
	            ret = asn1SccAuroraBatteryCapacity_ACN_Encode((&(pVal->battery_capacity)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode solar_panel_voltage */
	                ret = asn1SccAuroraVoltage_ACN_Encode((&(pVal->solar_panel_voltage)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode solar_panel_current */
	                    ret = asn1SccAuroraCurrent_ACN_Encode((&(pVal->solar_panel_current)), pBitStrm, pErrCode, FALSE);
	                }   /*COVERAGE_IGNORE*/
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccAuroraControllerStatus_ACN_Decode(asn1SccAuroraControllerStatus* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode payload_temperature */
	ret = asn1SccAuroraTemperature_ACN_Decode((&(pVal->payload_temperature)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode payload_flow_rate */
	    ret = asn1SccAuroraFlowRate_ACN_Decode((&(pVal->payload_flow_rate)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode battery_capacity */
	        ret = asn1SccAuroraBatteryCapacity_ACN_Decode((&(pVal->battery_capacity)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode solar_panel_voltage */
	            ret = asn1SccAuroraVoltage_ACN_Decode((&(pVal->solar_panel_voltage)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode solar_panel_current */
	                ret = asn1SccAuroraCurrent_ACN_Decode((&(pVal->solar_panel_current)), pBitStrm, pErrCode);
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
	}   /*COVERAGE_IGNORE*/

    return ret && asn1SccAuroraControllerStatus_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccT_Int32_Equal(const asn1SccT_Int32* pVal1, const asn1SccT_Int32* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccT_Int32_IsConstraintValid(const asn1SccT_Int32* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-2147483648L <= (*(pVal))) && ((*(pVal)) <= 2147483647L));
    *pErrCode = ret ? 0 :  ERR_T_INT32; 

	return ret;
}

void asn1SccT_Int32_Initialize(asn1SccT_Int32* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccT_Int32_Encode(const asn1SccT_Int32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_Int32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -2147483648LL, 2147483647LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Int32_Decode(asn1SccT_Int32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -2147483648LL, 2147483647LL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_INT32;

	return ret  && asn1SccT_Int32_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_Int32_ACN_Encode(const asn1SccT_Int32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_Int32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -2147483648LL, 2147483647LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Int32_ACN_Decode(asn1SccT_Int32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -2147483648LL, 2147483647LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_INT32;

    return ret && asn1SccT_Int32_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccT_UInt32_Equal(const asn1SccT_UInt32* pVal1, const asn1SccT_UInt32* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccT_UInt32_IsConstraintValid(const asn1SccT_UInt32* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 4294967295UL);
    *pErrCode = ret ? 0 :  ERR_T_UINT32; 

	return ret;
}

void asn1SccT_UInt32_Initialize(asn1SccT_UInt32* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccT_UInt32_Encode(const asn1SccT_UInt32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_UInt32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4294967295LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_UInt32_Decode(asn1SccT_UInt32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_UINT32;

	return ret  && asn1SccT_UInt32_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_UInt32_ACN_Encode(const asn1SccT_UInt32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_UInt32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4294967295LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_UInt32_ACN_Decode(asn1SccT_UInt32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_UINT32;

    return ret && asn1SccT_UInt32_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccT_Int8_Equal(const asn1SccT_Int8* pVal1, const asn1SccT_Int8* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccT_Int8_IsConstraintValid(const asn1SccT_Int8* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-128L <= (*(pVal))) && ((*(pVal)) <= 127L));
    *pErrCode = ret ? 0 :  ERR_T_INT8; 

	return ret;
}

void asn1SccT_Int8_Initialize(asn1SccT_Int8* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccT_Int8_Encode(const asn1SccT_Int8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_Int8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -128, 127);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Int8_Decode(asn1SccT_Int8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -128, 127);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_INT8;

	return ret  && asn1SccT_Int8_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_Int8_ACN_Encode(const asn1SccT_Int8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_Int8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -128, 127);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Int8_ACN_Decode(asn1SccT_Int8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -128, 127);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_INT8;

    return ret && asn1SccT_Int8_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccT_UInt8_Equal(const asn1SccT_UInt8* pVal1, const asn1SccT_UInt8* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccT_UInt8_IsConstraintValid(const asn1SccT_UInt8* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 255UL);
    *pErrCode = ret ? 0 :  ERR_T_UINT8; 

	return ret;
}

void asn1SccT_UInt8_Initialize(asn1SccT_UInt8* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccT_UInt8_Encode(const asn1SccT_UInt8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_UInt8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_UInt8_Decode(asn1SccT_UInt8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_UINT8;

	return ret  && asn1SccT_UInt8_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_UInt8_ACN_Encode(const asn1SccT_UInt8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_UInt8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_UInt8_ACN_Decode(asn1SccT_UInt8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_UINT8;

    return ret && asn1SccT_UInt8_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccT_Boolean_Equal(const asn1SccT_Boolean* pVal1, const asn1SccT_Boolean* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccT_Boolean_IsConstraintValid(const asn1SccT_Boolean* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

void asn1SccT_Boolean_Initialize(asn1SccT_Boolean* pVal)
{
	(void)pVal;


	(*(pVal)) = FALSE;
}

flag asn1SccT_Boolean_Encode(const asn1SccT_Boolean* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_Boolean_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_AppendBit(pBitStrm,(*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Boolean_Decode(asn1SccT_Boolean* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_ReadBit(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_BOOLEAN;

	return ret  && asn1SccT_Boolean_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_Boolean_ACN_Encode(const asn1SccT_Boolean* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_Boolean_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_AppendBit(pBitStrm,(*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Boolean_ACN_Decode(asn1SccT_Boolean* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_ReadBit(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_BOOLEAN;

    return ret && asn1SccT_Boolean_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccT_Null_Record_Equal(const asn1SccT_Null_Record* pVal1, const asn1SccT_Null_Record* pVal2)
{
	(void)pVal1;
	(void)pVal2;
	return TRUE;

}

flag asn1SccT_Null_Record_IsConstraintValid(const asn1SccT_Null_Record* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

void asn1SccT_Null_Record_Initialize(asn1SccT_Null_Record* pVal)
{
	(void)pVal;


}

flag asn1SccT_Null_Record_Encode(const asn1SccT_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	(void)pBitStrm;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_Null_Record_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Null_Record_Decode(asn1SccT_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;
	(void)pBitStrm;



	return ret  && asn1SccT_Null_Record_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_Null_Record_ACN_Encode(const asn1SccT_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	(void)pBitStrm;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_Null_Record_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Null_Record_ACN_Decode(asn1SccT_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	(void)pBitStrm;
	*pErrCode = 0;



    return ret && asn1SccT_Null_Record_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccPID_Range_Equal(const asn1SccPID_Range* pVal1, const asn1SccPID_Range* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccPID_Range_IsConstraintValid(const asn1SccPID_Range* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 6UL);
    *pErrCode = ret ? 0 :  ERR_PID_RANGE; 

	return ret;
}

void asn1SccPID_Range_Initialize(asn1SccPID_Range* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccPID_Range_Encode(const asn1SccPID_Range* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccPID_Range_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 6);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccPID_Range_Decode(asn1SccPID_Range* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 6);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_PID_RANGE;

	return ret  && asn1SccPID_Range_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccPID_Range_ACN_Encode(const asn1SccPID_Range* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccPID_Range_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 6);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccPID_Range_ACN_Decode(asn1SccPID_Range* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 6);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_PID_RANGE;

    return ret && asn1SccPID_Range_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccPID_Equal(const asn1SccPID* pVal1, const asn1SccPID* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccPID_IsConstraintValid(const asn1SccPID* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((((((((((*(pVal)) == PID_algorithms)) || (((*(pVal)) == PID_controller)))) || (((*(pVal)) == PID_electrics_power_supply)))) || (((*(pVal)) == PID_master_clock)))) || (((*(pVal)) == PID_mmi)))) || (((*(pVal)) == PID_payload)))) || (((*(pVal)) == PID_env)));
    *pErrCode = ret ? 0 :  ERR_PID; 

	return ret;
}

void asn1SccPID_Initialize(asn1SccPID* pVal)
{
	(void)pVal;


	(*(pVal)) = PID_algorithms;
}

flag asn1SccPID_Encode(const asn1SccPID* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccPID_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) 
	    {
	        case PID_algorithms:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 6);
	        	break;
	        case PID_controller:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 6);
	        	break;
	        case PID_electrics_power_supply:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 6);
	        	break;
	        case PID_master_clock:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 6);
	        	break;
	        case PID_mmi:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 6);
	        	break;
	        case PID_payload:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 6);
	        	break;
	        case PID_env:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 6, 0, 6);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_PID; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccPID_Decode(asn1SccPID* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 6);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_PID;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = PID_algorithms;
	                break;
	            case 1: 
	                (*(pVal)) = PID_controller;
	                break;
	            case 2: 
	                (*(pVal)) = PID_electrics_power_supply;
	                break;
	            case 3: 
	                (*(pVal)) = PID_master_clock;
	                break;
	            case 4: 
	                (*(pVal)) = PID_mmi;
	                break;
	            case 5: 
	                (*(pVal)) = PID_payload;
	                break;
	            case 6: 
	                (*(pVal)) = PID_env;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_PID;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = PID_algorithms;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && asn1SccPID_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccPID_ACN_Encode(const asn1SccPID* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccPID_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) { 
	        case PID_algorithms:
	            intVal = 0;
	            break;
	        case PID_controller:
	            intVal = 1;
	            break;
	        case PID_electrics_power_supply:
	            intVal = 2;
	            break;
	        case PID_master_clock:
	            intVal = 3;
	            break;
	        case PID_mmi:
	            intVal = 4;
	            break;
	        case PID_payload:
	            intVal = 5;
	            break;
	        case PID_env:
	            intVal = 6;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_PID;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, intVal, 0, 6);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccPID_ACN_Decode(asn1SccPID* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(intVal)), 0, 6);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_PID;
	if (ret) {
	    switch (intVal) {
	        case 0:
	            (*(pVal)) = PID_algorithms;
	            break;
	        case 1:
	            (*(pVal)) = PID_controller;
	            break;
	        case 2:
	            (*(pVal)) = PID_electrics_power_supply;
	            break;
	        case 3:
	            (*(pVal)) = PID_master_clock;
	            break;
	        case 4:
	            (*(pVal)) = PID_mmi;
	            break;
	        case 5:
	            (*(pVal)) = PID_payload;
	            break;
	        case 6:
	            (*(pVal)) = PID_env;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_PID;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && asn1SccPID_IsConstraintValid(pVal, pErrCode);
}

