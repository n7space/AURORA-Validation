/* Body file for function Client1
 * Generated by TASTE (kazoo/templates/skeletons/c-body/function.tmplt)
 * You can edit this file, it will not be overwritten

    !! IMPORTANT                                                        !!
    !! When you modify your design (interface view), you must update    !!
    !! the procedures corresponding to the provided interfaces in this  !!
    !! file. The up-to-date signatures can be found in the .ads file.   !!
*/
#include "client1.h"
#include <stdio.h>

typedef enum {
    SUBSCRIBE,
    CHECK_CREATE_1,
    CHECK_CREATE_2,
    CHECK_CREATE_3,
    CHECK_CREATE_4,
    CHECK_CREATE_5,
    CHECK_RETRIEVE_BY_TIMESTAMP,
    CHECK_RETRIEVE_BY_TIMESTAMP_EMPTY,
    WAIT_FOR_RESULTS,
    FINISHED
} Client1State;

static Client1State state;

static asn1SccDataStoreCreateRequest create_request;
static asn1SccDataStoreRetrieveTimestampRangeRequest retrieve_request;

static asn1SccDataStoreKeyType expected_item_1_key;
static asn1SccDataStoreKeyType expected_item_2_key;
static asn1SccDataStoreKeyType expected_item_3_key;

static int expected_item_1_retrieved;
static int expected_item_2_retrieved;
static int expected_item_3_retrieved;
static int expected_empty_result_retrieved;

static asn1SccULongInteger starting_time;
static asn1SccULongInteger ending_time;

static asn1SccULongInteger starting_time_for_empty;
static asn1SccULongInteger ending_time_for_empty;

static int create_1_ok;
static int create_2_ok;
static int create_3_ok;
static int create_4_ok;
static int create_5_ok;

void client1_startup(void)
{
    state = SUBSCRIBE;
    create_1_ok = 0;
    create_2_ok = 0;
    create_3_ok = 0;
    create_4_ok = 0;
    create_5_ok = 0;
    expected_item_1_retrieved = 0;
    expected_item_2_retrieved = 0;
    expected_item_3_retrieved = 0;
    expected_empty_result_retrieved = 0;
}

void client1_PI_Trigger(void)
{
    asn1SccT_Boolean should_notify = 1;
    switch(state)
    {
    case SUBSCRIBE:
        client1_RI_subscribe_to_event(&event_id_datastore_notify, &should_notify);
        printf("Subscribed\n");
        fflush(stdout);
        state = CHECK_CREATE_1;
        break;

    case CHECK_CREATE_1:
        printf("Checking create 1\n");
        fflush(stdout);
        create_request.behaviour = DataStoreCreateRequest_behaviour_reject_when_overflow;
        create_request.item_value.kind = DataStoreValueType_coefficient_PRESENT;
        create_request.item_value.u.coefficient = 1;
        client1_RI_Create(&create_request);
        state = CHECK_CREATE_2;
        break;

    case CHECK_CREATE_2:
        if(!create_1_ok)
        {
            state = FINISHED;
        }
        else
        {
            client1_RI_ObetTime(&starting_time);
            printf("Checking create 2\n");
            fflush(stdout);
            create_request.behaviour = DataStoreCreateRequest_behaviour_reject_when_overflow;
            create_request.item_value.kind = DataStoreValueType_coefficient_PRESENT;
            create_request.item_value.u.coefficient = 2;
            client1_RI_Create(&create_request);
            state = CHECK_CREATE_3;
        }
        break;

    case CHECK_CREATE_3:
        if(!create_2_ok)
        {
            state = FINISHED;
        }
        else
        {
            printf("Checking create 3\n");
            fflush(stdout);
            create_request.behaviour = DataStoreCreateRequest_behaviour_reject_when_overflow;
            create_request.item_value.kind = DataStoreValueType_coefficient_PRESENT;
            create_request.item_value.u.coefficient = 3;
            client1_RI_Create(&create_request);
            state = CHECK_CREATE_4;
        }
        break;

    case CHECK_CREATE_4:
        if(!create_3_ok)
        {
            state = FINISHED;
        }
        else
        {
            printf("Checking create 4\n");
            fflush(stdout);
            create_request.behaviour = DataStoreCreateRequest_behaviour_reject_when_overflow;
            create_request.item_value.kind = DataStoreValueType_coefficient_PRESENT;
            create_request.item_value.u.coefficient = 4;
            client1_RI_Create(&create_request);
            state = CHECK_CREATE_5;
        }
        break;

    case CHECK_CREATE_5:
        if(!create_4_ok)
        {
            state = FINISHED;
        }
        else
        {
            printf("Checking create 5\n");
            fflush(stdout);
            create_request.behaviour = DataStoreCreateRequest_behaviour_reject_when_overflow;
            create_request.item_value.kind = DataStoreValueType_coefficient_PRESENT;
            create_request.item_value.u.coefficient = 5;
            client1_RI_Create(&create_request);
            state = CHECK_RETRIEVE_BY_TIMESTAMP;
        }
        break;

    case CHECK_RETRIEVE_BY_TIMESTAMP:
        if(!create_5_ok)
        {
            state = FINISHED;
        }
        else
        {
            printf("Checking retrieve by timestamp, expecting three items\n");
            fflush(stdout);
            retrieve_request.starting_timestamp = starting_time;
            retrieve_request.ending_timestamp = ending_time;
            client1_RI_RetrieveByTimeRange(&retrieve_request);
            state = CHECK_RETRIEVE_BY_TIMESTAMP_EMPTY;
            client1_RI_ObetTime(&starting_time_for_empty);
        }
        break;

    case CHECK_RETRIEVE_BY_TIMESTAMP_EMPTY:
        if(! expected_item_1_retrieved || ! expected_item_2_retrieved || ! expected_item_3_retrieved)
        {
            state = FINISHED;
        }
        else
        {
            printf("Checking retrieve by timestamp, expecting empty result\n");
            fflush(stdout);
            retrieve_request.starting_timestamp = starting_time_for_empty;
            retrieve_request.ending_timestamp = ending_time_for_empty;
            client1_RI_RetrieveByTimeRange(&retrieve_request);
            state = WAIT_FOR_RESULTS;
        }
        break;

    case WAIT_FOR_RESULTS:
        if(expected_empty_result_retrieved)
        {
            printf("Test succeed\n");
            fflush(stdout);
        }
        else
        {
            printf("Test failed\n");
            fflush(stdout);
        }
        state = FINISHED;
        break;

    case FINISHED:
        break;
    }
}

void client1_PI_notify
      (const asn1SccT_EventMessage *IN_eventmessage)
{
    switch(state)
    {
    case SUBSCRIBE:
        break;

    case CHECK_CREATE_1:
        break;

    case CHECK_CREATE_2:
        if(IN_eventmessage->kind != T_EventMessage_item_created_PRESENT)
        {
            printf("Unexpected Data Store behaviour\n");
            fflush(stdout);
            return;
        }
        create_1_ok = 1;
        printf("Item 1 created\n");
        fflush(stdout);
        break;

    case CHECK_CREATE_3:
        if(IN_eventmessage->kind != T_EventMessage_item_created_PRESENT)
        {
            printf("Unexpected Data Store behaviour\n");
            fflush(stdout);
            return;
        }
        create_2_ok = 1;
        expected_item_1_key = IN_eventmessage->u.item_created.item_key;
        printf("Item 2 created\n");
        fflush(stdout);
        break;

    case CHECK_CREATE_4:
        if(IN_eventmessage->kind != T_EventMessage_item_created_PRESENT)
        {
            printf("Unexpected Data Store behaviour\n");
            fflush(stdout);
            return;
        }
        create_3_ok = 1;
        expected_item_2_key = IN_eventmessage->u.item_created.item_key;
        printf("Item 3 created\n");
        fflush(stdout);
        break;

    case CHECK_CREATE_5:
        if(IN_eventmessage->kind != T_EventMessage_item_created_PRESENT)
        {
            printf("Unexpected Data Store behaviour\n");
            fflush(stdout);
            return;
        }
        create_4_ok = 1;
        expected_item_3_key = IN_eventmessage->u.item_created.item_key;
        client1_RI_ObetTime(&ending_time);
        printf("Item 4 created\n");
        fflush(stdout);
        break;

    case CHECK_RETRIEVE_BY_TIMESTAMP:
        if(IN_eventmessage->kind != T_EventMessage_item_created_PRESENT)
        {
            printf("Unexpected Data Store behaviour\n");
            fflush(stdout);
            return;
        }
        create_5_ok = 1;
        printf("Item 5 created\n");
        fflush(stdout);
        break;

    case CHECK_RETRIEVE_BY_TIMESTAMP_EMPTY:
        printf("Unexpected Data Store behaviour\n");
        fflush(stdout);
        break;
    case WAIT_FOR_RESULTS:
        printf("Unexpected Data Store behaviour\n");
        fflush(stdout);
        break;

    case FINISHED:
        break;
    }
}

void client1_PI_notifyRetrieve
      (const asn1SccT_EventRetrieveMessage *IN_eventmessage)

{
   if(IN_eventmessage->kind != T_EventRetrieveMessage_item_by_timestamp_retrieved_PRESENT)
   {
       printf("Unexpected Data Store behaviour\n");
       fflush(stdout);
       return;
   }

   if(state == CHECK_RETRIEVE_BY_TIMESTAMP_EMPTY)
   {
       if(IN_eventmessage->u.item_by_timestamp_retrieved.kind == T_EventRetrieveMessage_item_by_timestamp_retrieved_item_PRESENT
               && IN_eventmessage->u.item_by_timestamp_retrieved.u.item.item_key == expected_item_1_key)
       {
           if(expected_item_1_retrieved)
           {
               printf("Unexpected Data Store behaviour\n");
               fflush(stdout);
           }
           else
           {
               printf("Expected item 1 retrieved\n");
               fflush(stdout);
               expected_item_1_retrieved = 1;
           }
       }
       else if(IN_eventmessage->u.item_by_timestamp_retrieved.kind == T_EventRetrieveMessage_item_by_timestamp_retrieved_item_PRESENT
               && IN_eventmessage->u.item_by_timestamp_retrieved.u.item.item_key == expected_item_2_key)
       {
           if(expected_item_2_retrieved)
           {
               printf("Unexpected Data Store behaviour\n");
               fflush(stdout);
           }
           else
           {
               printf("Expected item 2 retrieved\n");
               fflush(stdout);
               expected_item_2_retrieved = 1;
           }
       }
       else if(IN_eventmessage->u.item_by_timestamp_retrieved.kind == T_EventRetrieveMessage_item_by_timestamp_retrieved_item_PRESENT
               && IN_eventmessage->u.item_by_timestamp_retrieved.u.item.item_key == expected_item_3_key)
       {
           if(expected_item_3_retrieved)
           {
               printf("Unexpected Data Store behaviour\n");
               fflush(stdout);
           }
           else
           {
               printf("Expected item 3 retrieved\n");
               fflush(stdout);
               expected_item_3_retrieved = 1;
           }
       }
       else if(IN_eventmessage->u.item_by_timestamp_retrieved.kind == T_EventRetrieveMessage_item_by_timestamp_retrieved_item_PRESENT)
       {
           printf("Unexpected Data Store behaviour\n");
           fflush(stdout);
       }
       else if(IN_eventmessage->u.item_by_timestamp_retrieved.kind == T_EventRetrieveMessage_item_by_timestamp_retrieved_finished_PRESENT)
       {
           if(expected_item_1_retrieved && expected_item_2_retrieved && expected_item_3_retrieved)
           {
               printf("All expected items retrieved\n");
               fflush(stdout);
               client1_RI_ObetTime(&ending_time_for_empty);
           }
           else
           {
               printf("Some expected items are missing\n");
               fflush(stdout);
           }
       }
       else
       {
           printf("Unexpected Data Store behaviour\n");
           fflush(stdout);
       }
   }
   else if(state == WAIT_FOR_RESULTS)
   {
       if(IN_eventmessage->u.item_by_timestamp_retrieved.kind == T_EventRetrieveMessage_item_by_timestamp_retrieved_finished_PRESENT)
       {
           expected_empty_result_retrieved = 1;
       }
       else
       {
           expected_empty_result_retrieved = 0;
           state = FINISHED;
       }
   }
   else
   {
       printf("Unexpected Data Store behaviour\n");
       fflush(stdout);
   }
}


